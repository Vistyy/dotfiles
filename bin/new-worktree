#!/bin/bash
# Creates a new git worktree for agentic development
#
# Usage:
#   new-worktree --branch feat/my-feature
#   new-worktree --branch feat/my-feature --from develop
#   new-worktree --pick-code

set -euo pipefail

# Path helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_COPY_MANIFEST="$SCRIPT_DIR/new-worktree.copylist"
REPO_COPY_MANIFEST=""
COPY_MANIFEST_OVERRIDE=""
COPY_MANIFEST=""

# Defaults
REPO_ROOT="$HOME/projects/budgeat"
WORKTREES_DIR="$HOME/projects/budgeat.worktrees"
BASE_BRANCH="main"
BRANCH_NAME=""
OPEN_CODE=false
PICK_CODE=false
RUN_SETUP=true

usage() {
    echo "Usage:"
    echo "  new-worktree --branch NAME [OPTIONS]"
    echo "  new-worktree --pick-code"
    echo ""
    echo "Options:"
    echo "  --branch, -b NAME     Branch name for the new worktree (required)"
    echo "  --from, -f BRANCH     Base branch to create from (default: main)"
    echo "  --copylist, -l FILE   Copy manifest file of repo-relative paths"
    echo "                       (default: $REPO_ROOT/.worktree.copylist if present,"
    echo "                                 else $SCRIPT_COPY_MANIFEST)"
    echo "  --code, -C            Also open VS Code for the new worktree (opt-in)"
    echo "  --no-setup            Do not run setup (uv sync && just q)"
    echo "  --pick-code, -c       Select an existing worktree (fzf if available) and open VS Code"
    echo "  --help, -h            Show this help"
}

die() {
    printf "Error: %s\n" "$*" >&2
    exit 1
}

require_cmd() {
    command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

prompt_read() {
    local prompt="$1"
    local var_name="$2"
    if [[ -r /dev/tty ]]; then
        read -r -p "$prompt" "$var_name" </dev/tty || return 1
    else
        read -r -p "$prompt" "$var_name" || return 1
    fi
}

select_worktree_dir() {
    local dir="$1"
    git -C "$dir" rev-parse --show-toplevel >/dev/null 2>&1 || die "--pick-code requires a git repo (REPO_ROOT=$dir)"

    local entries
    entries="$(git -C "$dir" worktree list --porcelain 2>/dev/null || true)"
    [[ -n "${entries:-}" ]] || die "No git worktrees found (REPO_ROOT=$dir)"

    if command -v fzf >/dev/null 2>&1; then
        local picked
        picked="$(
            printf "%s\n" "$entries" \
                | awk '
                    BEGIN { p=""; b=""; d="" }
                    $1=="worktree" { if (p!="") { printf "%s\t%s\n", p, (b==""?d:b) } p=$2; b=""; d="" }
                    $1=="branch" { b=$2 }
                    $1=="detached" { d="(detached)" }
                    END { if (p!="") { printf "%s\t%s\n", p, (b==""?d:b) } }
                  ' \
                | fzf --prompt="Worktree> " \
                | cut -f1
        )"
        [[ -n "${picked:-}" ]] || die "No worktree selected"
        printf "%s" "$picked"
        return 0
    fi

    local paths
    paths="$(printf "%s\n" "$entries" | awk '$1=="worktree"{print $2}')"
    [[ -n "${paths:-}" ]] || die "No git worktrees found (REPO_ROOT=$dir)"

    local i=1
    printf "Worktrees:\n" >&2
    while IFS= read -r p; do
        [[ -n "$p" ]] || continue
        local b
        b="$(printf "%s\n" "$entries" | awk -v want="$p" '
          $1=="worktree"{p=$2}
          $1=="branch" && p==want {print $2; exit}
          $1=="detached" && p==want {print "(detached)"; exit}
        ')"
        [[ -n "${b:-}" ]] || b="(unknown)"
        printf "  %d) %s  %s\n" "$i" "$p" "$b" >&2
        i=$((i + 1))
    done <<< "$paths"

    local pick
    prompt_read "Select worktree (1-$((i - 1))): " pick || die "Selection failed"
    [[ "$pick" =~ ^[0-9]+$ ]] || die "Invalid selection: $pick"
    (( pick >= 1 && pick < i )) || die "Out of range selection: $pick"
    printf "%s\n" "$paths" | sed -n "${pick}p"
}

open_vscode_for_worktree() {
    local worktree_path="$1"
    require_cmd code
    if [[ -f "$worktree_path/budgeat.code-workspace" ]]; then
        code "$worktree_path/budgeat.code-workspace" || true
    else
        code "$worktree_path" || true
    fi
}

run_setup_best_effort() {
    local worktree_path="$1"
    local title="$2"

    if command -v wt.exe >/dev/null 2>&1 && command -v wsl.exe >/dev/null 2>&1 && command -v wslpath >/dev/null 2>&1; then
        echo ""
        echo "==> Running setup in new terminal tab (uv sync && just q)"
        local win_path
        win_path="$(wslpath -w "$worktree_path")"
        local distro="${WSL_DISTRO_NAME:-Ubuntu}"

        if wt.exe -w 0 new-tab -d "$win_path" --title "$title" wsl.exe -d "$distro" -- bash -lc "cd '$worktree_path' && uv sync && just q"; then
            echo "    Setup launched in new terminal tab"
            return 0
        fi

        echo "    Failed to launch new terminal tab; running setup inline" >&2
    else
        echo ""
        echo "==> Running setup (uv sync && just q)"
    fi

    (
        set +e
        cd "$worktree_path" || exit 0
        uv sync && just q
        rc=$?
        if (( rc != 0 )); then
            echo "    Setup failed (exit $rc)" >&2
        fi
        exit 0
    )
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    # Support grouping short flags, e.g. `-hfcFILE` (getopts-style).
    # Options that take a value follow getopts behavior:
    # -bVALUE uses VALUE; -b VALUE uses next argv.
    if [[ "${1:-}" =~ ^-[^-]{2,}$ ]]; then
        short_cluster="${1#-}"
        expanded=()
        for ((i=0; i<${#short_cluster}; i++)); do
            ch="${short_cluster:i:1}"
            case "$ch" in
                b|f|l)
                    if (( i + 1 < ${#short_cluster} )); then
                        expanded+=("-$ch" "${short_cluster:i+1}")
                    else
                        expanded+=("-$ch")
                    fi
                    break
                    ;;
                *)
                    expanded+=("-$ch")
                    ;;
            esac
        done
        set -- "${expanded[@]}" "${@:2}"
        continue
    fi

    case $1 in
        --branch|-b)
            BRANCH_NAME="$2"
            shift 2
            ;;
        --from|-f)
            BASE_BRANCH="$2"
            shift 2
            ;;
        --copylist|-l)
            COPY_MANIFEST_OVERRIDE="$2"
            shift 2
            ;;
        --code)
            OPEN_CODE=true
            shift
            ;;
        -C)
            OPEN_CODE=true
            shift
            ;;
        --no-setup)
            RUN_SETUP=false
            shift
            ;;
        --pick-code)
            PICK_CODE=true
            shift
            ;;
        -c)
            PICK_CODE=true
            shift
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        *)
            die "Unknown argument: $1"
            ;;
    esac
done

if [[ "$PICK_CODE" == "true" ]]; then
    require_cmd git
    worktree_path="$(select_worktree_dir "$REPO_ROOT")"
    open_vscode_for_worktree "$worktree_path"
    exit 0
fi

REPO_COPY_MANIFEST="$REPO_ROOT/.worktree.copylist"
if [[ -n "$COPY_MANIFEST_OVERRIDE" ]]; then
    COPY_MANIFEST="$COPY_MANIFEST_OVERRIDE"
elif [[ -f "$REPO_COPY_MANIFEST" ]]; then
    COPY_MANIFEST="$REPO_COPY_MANIFEST"
else
    COPY_MANIFEST="$SCRIPT_COPY_MANIFEST"
fi

[[ -n "$BRANCH_NAME" ]] || die "Missing required --branch NAME"

# Create directory name from branch (replace / with -)
dir_name="${BRANCH_NAME//\//-}"
WORKTREE_PATH="$WORKTREES_DIR/$dir_name"

echo "==> Creating worktree"
echo "    Branch: $BRANCH_NAME"
echo "    From: $BASE_BRANCH"
echo "    Path: $WORKTREE_PATH"
echo ""

# Ensure worktrees directory exists
mkdir -p "$WORKTREES_DIR"

# Create the worktree
cd "$REPO_ROOT"
require_cmd git
git fetch origin "$BASE_BRANCH"
if [[ -d "$WORKTREE_PATH" && -e "$WORKTREE_PATH/.git" ]]; then
    echo "==> Worktree already exists; reusing"
else
    git worktree add --no-track -b "$BRANCH_NAME" "$WORKTREE_PATH" "origin/$BASE_BRANCH"
fi

echo ""
echo "==> Copying gitignored files"

trim() {
    local s="$1"
    # Trim leading whitespace
    s="${s#"${s%%[![:space:]]*}"}"
    # Trim trailing whitespace
    s="${s%"${s##*[![:space:]]}"}"
    printf '%s' "$s"
}

is_unsafe_relpath() {
    local p="$1"
    [[ -z "$p" ]] && return 0
    [[ "$p" == /* ]] && return 0
    [[ "$p" == ".." || "$p" == ../* || "$p" == */../* || "$p" == */.. ]] && return 0
    return 1
}

copy_relpath() {
    local relpath="$1"
    local src="$REPO_ROOT/$relpath"
    local dest="$WORKTREE_PATH/$relpath"

    if command -v rsync >/dev/null 2>&1; then
        (cd "$REPO_ROOT" && rsync -aR "$relpath" "$WORKTREE_PATH/")
        return 0
    fi

    mkdir -p "$(dirname "$dest")"
    if [[ -d "$src" ]]; then
        mkdir -p "$dest"
        cp -a "$src/." "$dest/"
    else
        cp -a "$src" "$dest"
    fi
}

if [[ -f "$COPY_MANIFEST" ]]; then
    echo "    Manifest: $COPY_MANIFEST"
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Handle CRLF manifests
        line="${line%$'\r'}"
        relpath="$(trim "$line")"
        [[ -z "$relpath" ]] && continue
        [[ "$relpath" == \#* ]] && continue

        # Normalize directory entries like "models/" -> "models"
        relpath="${relpath%/}"

        if is_unsafe_relpath "$relpath"; then
            echo "    Skipping unsafe path in manifest: $relpath" >&2
            continue
        fi

        if [[ -e "$REPO_ROOT/$relpath" ]]; then
            copy_relpath "$relpath"
            echo "    Copied $relpath"
        fi
    done <"$COPY_MANIFEST"
else
    echo "    No manifest found at: $COPY_MANIFEST"
    echo "    Falling back to built-in defaults (.env, models/)"

    if [[ -f "$REPO_ROOT/.env" ]]; then
        cp "$REPO_ROOT/.env" "$WORKTREE_PATH/.env"
        echo "    Copied .env"
    fi

    if [[ -d "$REPO_ROOT/models" ]]; then
        mkdir -p "$WORKTREE_PATH/models"
        cp -r "$REPO_ROOT/models/"* "$WORKTREE_PATH/models/" 2>/dev/null || true
        echo "    Copied models/"
    fi
fi

if [[ "$OPEN_CODE" == "true" ]]; then
    echo ""
    echo "==> Opening VS Code (opt-in)"
    open_vscode_for_worktree "$WORKTREE_PATH"
fi

if [[ "$RUN_SETUP" == "true" ]]; then
    run_setup_best_effort "$WORKTREE_PATH" "Setup: $dir_name"
fi

echo ""
echo "âœ“ Worktree ready: $WORKTREE_PATH"
