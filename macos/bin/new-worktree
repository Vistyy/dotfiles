#!/usr/bin/env bash
set -euo pipefail

script_path="$(python3 - <<'PY' "${BASH_SOURCE[0]}"
import os, sys
print(os.path.realpath(sys.argv[1]))
PY
)"
script_dir="$(cd "$(dirname "$script_path")" && pwd)"
# shellcheck source=macos/bin/_worktree_tmux_lib.sh
source "$script_dir/_worktree_tmux_lib.sh"

script_copy_manifest="$script_dir/new-worktree.copylist"
copy_manifest_override=""

branch=""
base_branch="$DEFAULT_BASE_BRANCH"
open_code=false
pick_code=false

usage() {
  cat <<USAGE
Usage:
  new-worktree --branch NAME [OPTIONS]
  new-worktree --pick-code

Examples:
  new-worktree --branch feat/my-feature
  new-worktree --branch feat/my-feature --from develop
  new-worktree --pick-code

You can use getopts-style short options, e.g. -fdevelop or -bfeat/my-feature

Options:
  -b, --branch NAME   Branch name for the new worktree (required)
  -f, --from BRANCH   Base branch to create from (default: main)
  -l, --copylist FILE Copy manifest file of repo-relative paths
                    (default: $REPO_ROOT/.worktree.copylist if present,
                              else $script_copy_manifest)
  -C, --code          Also open VS Code for the new worktree (opt-in)
  -c, --pick-code     Select an existing worktree (fzf if available) and open VS Code
  -h, --help          Show help
USAGE
}

prompt_read() {
  local prompt="$1"
  local var_name="$2"
  if [[ -r /dev/tty ]]; then
    read -r -p "$prompt" "$var_name" </dev/tty || return 1
  else
    read -r -p "$prompt" "$var_name" || return 1
  fi
}

select_worktree_dir() {
  local dir="$1"
  git -C "$dir" rev-parse --show-toplevel >/dev/null 2>&1 || die "--pick-code requires a git repo (REPO_ROOT=$dir)"

  local entries
  entries="$(git -C "$dir" worktree list --porcelain 2>/dev/null || true)"
  [[ -n "${entries:-}" ]] || die "No git worktrees found (REPO_ROOT=$dir)"

  if command -v fzf >/dev/null 2>&1; then
    local picked
    picked="$(
      printf "%s\n" "$entries" \
        | awk '
            BEGIN { p=""; b=""; d="" }
            $1=="worktree" { if (p!="") { printf "%s\t%s\n", p, (b==""?d:b) } p=$2; b=""; d="" }
            $1=="branch" { b=$2 }
            $1=="detached" { d="(detached)" }
            END { if (p!="") { printf "%s\t%s\n", p, (b==""?d:b) } }
          ' \
        | fzf --prompt="Worktree> " \
        | cut -f1
    )"
    [[ -n "${picked:-}" ]] || die "No worktree selected"
    printf "%s" "$picked"
    return 0
  fi

  local paths
  paths="$(printf "%s\n" "$entries" | awk '$1=="worktree"{print $2}')"
  [[ -n "${paths:-}" ]] || die "No git worktrees found (REPO_ROOT=$dir)"

  local i=1
  err "Worktrees:"
  while IFS= read -r p; do
    [[ -n "$p" ]] || continue
    local b
    b="$(printf "%s\n" "$entries" | awk -v want="$p" '
      $1=="worktree"{p=$2}
      $1=="branch" && p==want {print $2; exit}
      $1=="detached" && p==want {print "(detached)"; exit}
    ')"
    [[ -n "${b:-}" ]] || b="(unknown)"
    err "  $i) $p  $b"
    i=$((i + 1))
  done <<< "$paths"

  local pick
  prompt_read "Select worktree (1-$((i - 1))): " pick || die "Selection failed"
  [[ "$pick" =~ ^[0-9]+$ ]] || die "Invalid selection: $pick"
  (( pick >= 1 && pick < i )) || die "Out of range selection: $pick"
  printf "%s\n" "$paths" | sed -n "${pick}p"
}

open_vscode_for_worktree() {
  local worktree_path="$1"
  require_cmd code
  if [[ -f "$worktree_path/budgeat.code-workspace" ]]; then
    code "$worktree_path/budgeat.code-workspace" || true
  else
    code "$worktree_path" || true
  fi
}

while [[ $# -gt 0 ]]; do
  # Support grouping short flags, e.g. `-hfcFILE` (getopts-style).
  # Options that take a value follow getopts behavior:
  # -bVALUE uses VALUE; -b VALUE uses next argv.
  if [[ "${1:-}" =~ ^-[^-]{2,}$ ]]; then
    short_cluster="${1#-}"
    expanded=()
    for ((i=0; i<${#short_cluster}; i++)); do
      ch="${short_cluster:i:1}"
      case "$ch" in
        b|f|l)
          if (( i + 1 < ${#short_cluster} )); then
            expanded+=("-$ch" "${short_cluster:i+1}")
          else
            expanded+=("-$ch")
          fi
          break
          ;;
        *)
          expanded+=("-$ch")
          ;;
      esac
    done
    set -- "${expanded[@]}" "${@:2}"
    continue
  fi

  case "$1" in
    -b|--branch) branch="${2:-}"; shift 2 ;;
    -f|--from) base_branch="${2:-}"; shift 2 ;;
    -l|--copylist) copy_manifest_override="${2:-}"; shift 2 ;;
    -C|--code) open_code=true; shift ;;
    -c|--pick-code) pick_code=true; shift ;;
    -h|--help) usage; exit 0 ;;
    *)
      die "Unknown argument: $1"
      ;;
  esac
done

if [[ "$pick_code" == "true" ]]; then
  require_cmd git
  worktree_path="$(select_worktree_dir "$REPO_ROOT")"
  open_vscode_for_worktree "$worktree_path"
  exit 0
fi

[[ -n "$branch" ]] || die "Missing required --branch NAME"

dir_name="$(branch_to_dir_name "$branch")"
worktree_path="$WORKTREES_DIR/$dir_name"

say "==> Creating worktree"
say "    Branch: $branch"
say "    From: $base_branch"
say "    Path: $worktree_path"
say ""

require_cmd git

mkdir -p "$WORKTREES_DIR"

cd "$REPO_ROOT"
git fetch origin "$base_branch"

if [[ -d "$worktree_path" && -e "$worktree_path/.git" ]]; then
  say "==> Worktree already exists; reusing"
else
  git worktree add --no-track -b "$branch" "$worktree_path" "origin/$base_branch"
fi

say ""
say "==> Copying gitignored files"
copy_gitignored_extras "$worktree_path" "$script_copy_manifest" "$copy_manifest_override"

if [[ "$open_code" == "true" ]]; then
  say ""
  say "==> Opening VS Code (opt-in)"
  open_vscode_for_worktree "$worktree_path"
fi

say ""
say "âœ“ Worktree ready: $worktree_path"
